{
  "version": 3,
  "sources": ["../../hull.js/src/intersect.js", "../../hull.js/src/grid.js", "../../hull.js/src/format.js", "../../hull.js/src/convex.js", "../../hull.js/src/hull.js"],
  "sourcesContent": ["function ccw(x1, y1, x2, y2, x3, y3) {           \n    const cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));\n    return cw > 0 ? true : cw < 0 ? false : true; // colinear\n}\n\nfunction intersect(seg1, seg2) {\n  const x1 = seg1[0][0], y1 = seg1[0][1],\n      x2 = seg1[1][0], y2 = seg1[1][1],\n      x3 = seg2[0][0], y3 = seg2[0][1],\n      x4 = seg2[1][0], y4 = seg2[1][1];\n\n    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n}\n\nmodule.exports = intersect;", "function Grid(points, cellSize) {\n    this._cells = [];\n    this._cellSize = cellSize;\n    this._reverseCellSize = 1 / cellSize;\n\n    for (let i = 0; i < points.length; i++) {\n        const point = points[i];\n        const x = this.coordToCellNum(point[0]);\n        const y = this.coordToCellNum(point[1]);\n        if (!this._cells[x]) {\n            const array = [];\n            array[y] = [point];\n            this._cells[x] = array;\n        } else if (!this._cells[x][y]) {\n            this._cells[x][y] = [point];\n        } else {\n            this._cells[x][y].push(point);\n        }\n    }\n}\n\nGrid.prototype = {\n    cellPoints: function(x, y) { // (Number, Number) -> Array\n        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];\n    },\n\n    rangePoints: function(bbox) { // (Array) -> Array\n        const tlCellX = this.coordToCellNum(bbox[0]);\n        const tlCellY = this.coordToCellNum(bbox[1]);\n        const brCellX = this.coordToCellNum(bbox[2]);\n        const brCellY = this.coordToCellNum(bbox[3]);\n        const points = [];\n\n        for (let x = tlCellX; x <= brCellX; x++) {\n            for (let y = tlCellY; y <= brCellY; y++) {\n                // replaced Array.prototype.push.apply to avoid hitting stack size limit on larger arrays.\n                for (let i = 0; i < this.cellPoints(x, y).length; i++) {\n                    points.push(this.cellPoints(x, y)[i]);\n                }\n            }\n        }\n\n        return points;\n    },\n\n    removePoint: function(point) { // (Array) -> Array\n        const cellX = this.coordToCellNum(point[0]);\n        const cellY = this.coordToCellNum(point[1]);\n        const cell = this._cells[cellX][cellY];\n        let pointIdxInCell;\n\n        for (let i = 0; i < cell.length; i++) {\n            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {\n                pointIdxInCell = i;\n                break;\n            }\n        }\n\n        cell.splice(pointIdxInCell, 1);\n\n        return cell;\n    },\n\n    trunc: Math.trunc || function(val) { // (number) -> number\n        return val - val % 1;\n    },\n\n    coordToCellNum: function(x) { // (number) -> number\n        return this.trunc(x * this._reverseCellSize);\n    },\n\n    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array\n        return [\n            bbox[0] - (scaleFactor * this._cellSize),\n            bbox[1] - (scaleFactor * this._cellSize),\n            bbox[2] + (scaleFactor * this._cellSize),\n            bbox[3] + (scaleFactor * this._cellSize)\n        ];\n    }\n};\n\nfunction grid(points, cellSize) {\n    return new Grid(points, cellSize);\n}\n\nmodule.exports = grid;", "module.exports = {\n\n    toXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            const _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');\n            return _getXY(pt);\n        });\n    },\n\n    fromXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            const _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');\n            return _getObj(pt);\n        });\n    }\n\n}", "function _cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\nfunction _upperTangent(pointset) {\n    const lower = [];\n    for (let l = 0; l < pointset.length; l++) {\n        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {\n            lower.pop();\n        }\n        lower.push(pointset[l]);\n    }\n    lower.pop();\n    return lower;\n}\n\nfunction _lowerTangent(pointset) {\n    const reversed = pointset.reverse(),\n        upper = [];\n    for (let u = 0; u < reversed.length; u++) {\n        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {\n            upper.pop();\n        }\n        upper.push(reversed[u]);\n    }\n    upper.pop();\n    return upper;\n}\n\n// pointset has to be sorted by X\nfunction convex(pointset) {\n    const upper = _upperTangent(pointset),\n          lower = _lowerTangent(pointset);\n    const convex = lower.concat(upper);\n    convex.push(pointset[0]);  \n    return convex;  \n}\n\nmodule.exports = convex;\n", "'use strict';\n\nconst intersect = require('./intersect.js');\nconst grid = require('./grid.js');\nconst formatUtil = require('./format.js');\nconst convexHull = require('./convex.js');\n\nfunction _filterDuplicates(pointset) {\n    const unique = [pointset[0]];\n    let lastPoint = pointset[0];\n    for (let i = 1; i < pointset.length; i++) {\n        const currentPoint = pointset[i];\n        if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {\n            unique.push(currentPoint);\n        }\n        lastPoint = currentPoint;\n    }\n    return unique;\n}\n\nfunction _sortByX(pointset) {\n    return pointset.sort(function(a, b) {\n        return (a[0] - b[0]) || (a[1] - b[1]);\n    });\n}\n\nfunction _sqLength(a, b) {\n    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\n\nfunction _cos(o, a, b) {\n    const aShifted = [a[0] - o[0], a[1] - o[1]],\n        bShifted = [b[0] - o[0], b[1] - o[1]],\n        sqALen = _sqLength(o, a),\n        sqBLen = _sqLength(o, b),\n        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n\n    return dot / Math.sqrt(sqALen * sqBLen);\n}\n\nfunction _intersect(segment, pointset) {\n    for (let i = 0; i < pointset.length - 1; i++) {\n        const seg = [pointset[i], pointset[i + 1]];\n        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||\n            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n            continue;\n        }\n        if (intersect(segment, seg)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _occupiedArea(pointset) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for (let i = pointset.length - 1; i >= 0; i--) {\n        if (pointset[i][0] < minX) {\n            minX = pointset[i][0];\n        }\n        if (pointset[i][1] < minY) {\n            minY = pointset[i][1];\n        }\n        if (pointset[i][0] > maxX) {\n            maxX = pointset[i][0];\n        }\n        if (pointset[i][1] > maxY) {\n            maxY = pointset[i][1];\n        }\n    }\n\n    return [\n        maxX - minX, // width\n        maxY - minY  // height\n    ];\n}\n\nfunction _bBoxAround(edge) {\n    return [\n        Math.min(edge[0][0], edge[1][0]), // left\n        Math.min(edge[0][1], edge[1][1]), // top\n        Math.max(edge[0][0], edge[1][0]), // right\n        Math.max(edge[0][1], edge[1][1])  // bottom\n    ];\n}\n\nfunction _midPoint(edge, innerPoints, convex) {\n    let point = null,\n        angle1Cos = MAX_CONCAVE_ANGLE_COS,\n        angle2Cos = MAX_CONCAVE_ANGLE_COS,\n        a1Cos, a2Cos;\n\n    for (let i = 0; i < innerPoints.length; i++) {\n        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n\n        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&\n            !_intersect([edge[0], innerPoints[i]], convex) &&\n            !_intersect([edge[1], innerPoints[i]], convex)) {\n\n            angle1Cos = a1Cos;\n            angle2Cos = a2Cos;\n            point = innerPoints[i];\n        }\n    }\n\n    return point;\n}\n\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n    let midPointInserted = false;\n\n    for (let i = 0; i < convex.length - 1; i++) {\n        const edge = [convex[i], convex[i + 1]];\n        // generate a key in the format X0,Y0,X1,Y1\n        const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];\n\n        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||\n            edgeSkipList.has(keyInSkipList)) { continue; }\n\n        let scaleFactor = 0;\n        let bBoxAround = _bBoxAround(edge);\n        let bBoxWidth;\n        let bBoxHeight;\n        let midPoint;\n        do {\n            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n\n            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);\n            scaleFactor++;\n        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n\n        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n            edgeSkipList.add(keyInSkipList);\n        }\n\n        if (midPoint !== null) {\n            convex.splice(i + 1, 0, midPoint);\n            grid.removePoint(midPoint);\n            midPointInserted = true;\n        }\n    }\n\n    if (midPointInserted) {\n        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n    }\n\n    return convex;\n}\n\nfunction hull(pointset, concavity, format) {\n    let maxEdgeLen = concavity || 20;\n\n    const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n\n    if (points.length < 4) {\n        const concave = points.concat([points[0]]);\n        return format ? formatUtil.fromXy(concave, format) : concave;\n    }\n\n    const occupiedArea = _occupiedArea(points);\n    const maxSearchArea = [\n        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n    ];\n\n    const convex = convexHull(points);\n    const innerPoints = points.filter(function(pt) {\n        return convex.indexOf(pt) < 0;\n    });\n\n    const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n\n    const concave = _concave(\n        convex, Math.pow(maxEdgeLen, 2),\n        maxSearchArea, grid(innerPoints, cellSize), new Set());\n\n    return format ? formatUtil.fromXy(concave, format) : concave;\n}\n\nconst MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nconst MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n\nmodule.exports = hull;\n"],
  "mappings": "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",
  "names": ["convex", "grid", "concave"]
}
